# 프록시와 연관관계 관리





### 프록시 ✨

- `em.getReference()`

  데이터베이스 조회를 미루는 가짜(프록시) 엔티티 객체 조회

  - 잘 쓰이지는 않지만 프록시를 알아야 즉시/지연로딩을 이해할 수 있다!

- `em.find()`

  데이터베이스를 통해서 실제 엔티티 객체 조회
  
  

### 프록시 객체의 초기화 및 동작 과정

- em.getReference() 사용시 찾고자하는 클래스 상속 받아 껍데기 클래스가 생성

- 프록시 객처는 생성시 target(객체 내부 값)을 갖지 않으므로

  JPA가 영속성 컨텍스트에 초기화 요청

  - 이 때 초기화는 삭제가 아닌 영속성 컨텍스트에 객체를 찾는 요청을 보낸거임

- 영속성 컨텍스트에 찾고자 하는 클래스가 없으면 DB를 조회함

- DB에서 가져와서 실제 ENTITY 생성

- 생성된 실제 ENTITY를 프록시 객체의 target과 연결시킴



### 프록시 특징 정리

- 프록시 객체는 처음 한 번만 초기화
- 초기화 때 프록시 객체가 실제 엔티티로 바뀌는 것이 아님
  - target에 값이 채워진 것 뿐
  - 원본 클래스와 객체 타입도 다름
    - JPA에서 타입 비교는 `instanceOf`를 사용하자! ✨
- 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 `em.getReference()`를 호출해도 실제 엔티티 반환
  - JPA는 하나의 영속성 컨텍스트에서 조회하는 같은 엔티티의 동일성을 보장하므로 굳이 새로운 프록시 객체를 반환하지 X
  - 한 번 만들어진 프록시를 또 호출할시 같은 프록시 객체를 반환함
    - 프록시 객체도 **동일성 보장**
- 실무에서 자주 발생하는 문제 💥
  - 영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일 때, 프록시를 초기화하면
    문제 발생
    
    - 프록시 객체를 초기화 할 수 없단 뜻은 영속성 컨텍스트에 없다는 뜻
    
    - 에러로그: `org.hibernate.LazyInitializationException` ✨
    
      자주 만날 친구니깐 외워놓자!



### 프록시 확인

- 프록시 인스턴스 초기화 여부 확인: 

  `PersistenceUnitUtil.isLoaded(Object entity)`

- 프록시 클래스 확인 방법:

  `entity.getClass().getXxx()` 출력

- 프록시 강제 초기화:

  `org.hibernate.Hibernate.initialize(entity)`



### 즉시 로딩과 지연 로딩

- 실무에서는 즉시로딩만 사용하자!



